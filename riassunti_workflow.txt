RIASSUNTO PROGETTO NINJATRADER - TRAPPED ORDERS PATTERN

OBIETTIVO DEL PROGETTO
======================
Sviluppare un indicatore NinjaTrader per il riconoscimento di pattern TRAPPED ORDERS 
utilizzando dati order flow (MBO/Level 2) da feed Rithmic su range bar.

STORICO LAVORO E MODIFICHE
==========================

1. COSTRUZIONE INFRASTRUTTURA DATI
----------------------------------
- Creati file dati tick-by-tick originali e range bar (data/raw/ES 06-25.Last.txt, data/raw/range_candles.csv).
- Implementata logica range bar fedele a NinjaTrader (phantom bars, chiusura precisa).
- Nei dati aggregati per livello di prezzo sono stati aggiunti volume, delta, bid_volume e ask_volume.

2. DEFINIZIONE E PRIMA IMPLEMENTAZIONE PATTERN
----------------------------------------------
- Definiti i pattern trapped orders: inversione rapida nella stessa candela, con varianti divergence (prezzo vs delta opposti) e confirmation (prezzo e delta allineati).
- Inizialmente la ricerca era vincolata a zone strutturali (HH_END, LL_END, HL_PULLBACK, LH_PULLBACK) identificate tramite massimi/minimi locali.
- Separazione tra logica di contesto (dove cercare) e quantitativa (cosa cercare).

3. PRIMA VERSIONE ANALISI QUANTITATIVA
--------------------------------------
- Analisi quantitativa parametrica: filtri su volume, delta, eccessi agli estremi, inversione di direzione.
- Pipeline: identificazione zone strutturali → ricerca pattern solo su queste zone → misurazione efficacia → validazione visiva tramite plotting.
- Output: pattern identificati e performance per zona strutturale.

4. REVISIONE E SEMPLIFICAZIONE WORKFLOW (MAGGIO 2025)
------------------------------------------------------
- **Abolita la ricerca vincolata alle sole zone strutturali:** ora la pipeline analizza tutte le candele, senza filtro di market structure.
- **Semplificata la logica di individuazione:** i filtri quantitativi vengono applicati su tutte le candele, senza classificazione preventiva delle zone.
- **Rimosse/ rese opzionali le funzioni di market structure:** la pipeline produce un unico file di output con tutti i pattern rilevati secondo i parametri quantitativi.
- **Aggiornamento della documentazione e dei report:** ora riferiti all’intero dataset, non più suddivisi per zona strutturale.
- **Motivazione:** aumentare la flessibilità e testare la robustezza dei parametri su tutto il flusso dati.
- **Nota:** la logica di market structure potrà essere reintrodotta come filtro opzionale in futuro.

5. NUOVI FILTRI E DEDUPLICA
---------------------------
- **Filtro sugli estremi:** vengono considerati solo i pattern in cui, nella finestra successiva (5, 10, 20 barre), non viene mai rotto l’estremo della candela di pattern nella direzione originaria.
- **Deduplica dei pattern:** se una candela rispetta il filtro per più finestre, viene mantenuta solo la versione con la finestra più lunga.

6. AGGIUNTA IMBALANCE E STATISTICHE DETTAGLIATE
-----------------------------------------------
- **Aggiunta rilevazione e salvataggio imbalance:** per ogni candela vengono calcolati e salvati i valori di imbalance (x2, x3, x4) sia lato alto che basso, nei primi/ultimi 3 livelli di prezzo.
- **Aggiunta statistica sulle candele con imbalance:** lo script di analisi statistica ora riporta, per ciascuna categoria (divergenti e non divergenti), quante candele presentano almeno un imbalance significativo.
- **Output statistico dettagliato:** il file di output delle statistiche riporta, per divergenti e non divergenti:
    - Statistiche max_excursion (punti di prezzo)
    - Statistiche n_bars_excursion (numero barre)
    - Distribuzione direzione prima/dopo
    - Distribuzione window
    - Numero e percentuale di candele con almeno un imbalance

7. FILE CREATI E MODIFICATI
---------------------------
- **Creati:**
  - `scripts/estrazione_stat_trapped_orders_pattern.py` (analisi statistica automatica dei risultati)
  - `stat/result_stat_xx_yy.txt` (output statistico per ogni combinazione di parametri)
  - `data/results/trapped_orders_volX_deltaY.csv` (output pattern filtrati per ogni combinazione di parametri)
- **Modificati:**
  - `scripts/ricerca_parametri_trapped_orders.py` (deduplica, filtro sugli estremi, calcolo imbalance, output dettagliato)
  - `riassunti_workflow.txt` (aggiornamento documentazione e tracciamento modifiche)

STRUTTURA ATTUALE DEL PROGETTO
==============================
progetto ninjatrader/
├── data/
│   ├── raw/
│   │   ├── ES 06-25.Last.txt
│   │   └── range_candles.csv
│   └── results/
│       └── trapped_orders_volX_deltaY.csv
├── stat/
│   └── result_stat_xx_yy.txt
├── scripts/
│   ├── ricerca_parametri_trapped_orders.py
│   └── estrazione_stat_trapped_orders_pattern.py
├── docs/
│   └── patternOrderFlow.txt
└── notebooks/

Ultimo aggiornamento: 27 maggio 2025

appunti del 29/05/2025
open_time,close_time,open,high,low,close,volume,delta_open,delta_high,delta_low,delta_close,direction,price_stats

ho trovato gli errori che guastano tutti gli script. e sono nella funzione price stat. 
ci deve essere stato un fraintendimento nella costruzuione del codice. cosa è il delta candela? 
il delta candela è  (somma di tutti i volumi ask su tutti i livelli di una candela) meno
 (la somma di tutti i bid di tutti i livelli di una candela). 
 delta open hight low e close nella stringa sono valori inutili 
 basati sul prezzo(non è questo che si intende con delta), possono essere eliminati.
  la colonna json price stat poi va riorganizzata perche anche questa riporta delle anomalie.
  2025-05-11 22:00:00.120,2025-05-11 22:00:00.144,5763.0,5764.75,5761.0,5761.0,83,1898,1946,1898,1945,-1,"{np.float64(5763.0): {'volume': np.int64(14), 'delta': np.int64(8), 'bid_volume': np.int64(3), 'ask_volume': np.int64(11)}, np.float64(5763.25): {'volume': np.int64(11), 'delta': np.int64(11), 'bid_volume': 0, 'ask_volume': np.int64(11)}, np.float64(5763.5): {'volume': np.int64(8), 'delta': np.int64(8), 'bid_volume': 0, 'ask_volume': np.int64(8)}, np.float64(5763.75): {'volume': np.int64(2), 'delta': np.int64(2), 'bid_volume': 0, 'ask_volume': np.int64(2)}, np.float64(5764.0): {'volume': np.int64(7), 'delta': np.int64(7), 'bid_volume': 0, 'ask_volume': np.int64(7)}, np.float64(5764.5): {'volume': np.int64(1), 'delta': np.int64(1), 'bid_volume': 0, 'ask_volume': np.int64(1)}, np.float64(5764.75): {'volume': np.int64(3), 'delta': np.int64(3), 'bid_volume': 0, 'ask_volume': np.int64(3)}, np.float64(5762.75): {'volume': np.int64(6), 'delta': np.int64(2), 'bid_volume': np.int64(2), 'ask_volume': np.int64(4)}, np.float64(5762.5): {'volume': np.int64(5), 'delta': np.int64(3), 'bid_volume': np.int64(1), 'ask_volume': np.int64(4)}, np.float64(5762.25): {'volume': np.int64(3), 'delta': np.int64(-1), 'bid_volume': np.int64(2), 'ask_volume': np.int64(1)}, np.float64(5762.0): {'volume': np.int64(3), 'delta': np.int64(-1), 'bid_volume': np.int64(2), 'ask_volume': np.int64(1)}, np.float64(5761.75): {'volume': np.int64(7), 'delta': np.int64(3), 'bid_volume': np.int64(2), 'ask_volume': np.int64(5)}, np.float64(5761.5): {'volume': np.int64(2), 'delta': np.int64(0), 'bid_volume': np.int64(1), 'ask_volume': np.int64(1)}, np.float64(5761.25): {'volume': np.int64(10), 'delta': np.int64(2), 'bid_volume': np.int64(4), 'ask_volume': np.int64(6)}, np.float64(5761.0): {'volume': np.int64(1), 'delta': np.int64(-1), 'bid_volume': np.int64(1), 'ask_volume': 0}}" il delta qui calcolato è su ogni livello e sottrae il bid dall'ask,(questo fatto su ogni livello  orizzontale è un calcolo inutile), la riga price stat dovrebbe riportare semplicemente bid su un  livello di prezzo e ask sul solito livello di prezzo e volume totale sul livello di prezzo, ma non il delta. la funzione delta per delta candela ti ho spiegato che cosa è e come va calcolata. poi andrebbero aggregati in modo ordinato i livelli di prezzo dal piu piccolo al piu grande e ciascuno dovrebbe riportare il vol totale, il suo ask, totale il suo bid totale. il calcolo delle imbalance cosi negli altri script sarà il divario percentuale tra il tot ask di un livello con il tot bid del suo ilvello dib adiacente superiore. i ilvelli bid all'estramo superiore di una candela e ask inferiore quasi sempre se non sempre saranno 0 per ovvi motivi che se vuoi e mi chiederai ti spiego. domande?
  se analizzi bene vedrai che ogni candela avra solo 8 livelli di prezzo.
  perche? i livelli si ripetono perche sono la costruzione di un calcolo
 che avviene da un dataframe tik by tik. questi livelli che si ripetono vanno aggregati 
  e messi in ordine dal piu piccolo al piu grande e vanno aggregati i valori per ogni livello. 
 troverari ad esempio in price stat prezzo x ripetuto piu volte e ciascuno con suo bid suo ask e volume.
 questo va aggregato e la risultante sarà x con tot bid tot ask tot volume.
 e i prezzi vanno elencati in ordine ascendente. la colonna volume del csv è volume totale 
candela che sarà la somma dei volumi su tutti i livelli di prezzo,
e la funzione per calcolare il delta candela te l'ho gia spiegata.
ora io cosa farei per non creare ulteriore confusione e non rompere delle logiche su gli script
che tutto sommato funzionano. i dati raw li lascerei stare e creerei uno script che 
riorganizza prendendo da range candle csv crea il range candle csv corretto con questo
output: open time, colse time, open, high,low,close,volume,delta candela
(tot ask riportati nei livelli-tot bid riportati nei livelli),directio, price stat:
livelle di prezzo 1 aggregato tot volume tot bid tot ask;
livello di prezzo 2 aggregato tot volume tot bid tot ask....livello di prezzo 8 aggregato....
ora io cosa farei per non creare ulteriore confusione e non rompere delle logiche su gli script
che tutto sommato funzionano. i dati raw li lascerei stare e creerei uno script che riorganizza
prendendo da range candle csv crea il range candle csv corretto con questo output: 
open time, colse time, open, high,low,close,volume,delta candela
(tot ask riportati nei livelli-tot bid riportati nei livelli),
directio, price stat: livelle di prezzo 1 aggregato tot volume tot bid tot ask;
livello di prezzo 2 aggregato tot volume tot bid tot ask....livello di prezzo 8 aggregato....
e per questo dobbiamo creare uno script di pulizia chiamato pulizia_candle_data_raw.py 
e restituisce il csv pulito_range_candles.csv che sarà la bare dati per tutti gli altri script.
prime rettifiche ricerca_parametri_trapped_orders: il delta agli estremi
(mi sono sbagliato usando un gergo tecnico non corretto) in realtà dovrebbe
misurare eccessi di ask a gli estremo superiore o eccesso di bid all'estremo inferiore.
che significa? se abbiamo ad esempio un up trende e il movimento si arresta bruscamente
per un inversione che succederà su l'ultima candela? avremmo dei compratori intrappolati,
operatori che si mettono in acquisto su i massimi ma vengono accumulati su un livell
noi allora cercheremo anomalie sull'ask. dovremmo trovare un sistema per misurare 
questa anomalia ad esempio confrontando gli ultimi livelli ask con i livelli bid sotto adiacenti
per vedere se ci sono embalance, vedere se c'è un esaurimanto che significa su i livelli ask
avere il penultimo o terzultimo livello con ask altissimo e livello ask successivo drasticamente 
ridotto cioè magari <10% del livello considerato anomalo. il volume alto su gli ultimi livelli
è un indicazione l'ask per livello estremo superiore e il bid per livello estremo inferiore
sono la conferma che ci sono trapped orders.domande?

8. CORREZIONE FONDAMENTALE LOGICA DATI (29/05/2025)
--------------------------------------------------
**PROBLEMA IDENTIFICATO:** Errori strutturali nella costruzione dei dati che compromettevano tutti gli script:

**Delta Candela (CORRETTO):**
- VECCHIO: delta per livello (bid-ask su ogni livello) ❌
- NUOVO: delta candela = (Σ ask_tutti_livelli) - (Σ bid_tutti_livelli) ✅

**Price Stats (CORRETTO):**
- VECCHIO: livelli duplicati con delta per livello ❌  
- NUOVO: livelli aggregati ordinati (8 livelli) con volume_tot, bid_tot, ask_tot ✅

**Colonne Obsolete Rimosse:**
- delta_open, delta_high, delta_low, delta_close (basati su prezzo, non order flow)

**Nuova Struttura Output:**
open_time, close_time, open, high, low, close, volume, delta_candela, direction, price_stats
